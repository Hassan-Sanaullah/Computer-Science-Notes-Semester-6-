# Boundary Following (Tracing)

Boundary-following algorithms are used to trace the boundary of a region in an image. The points along the boundary are ordered either in a clockwise or counterclockwise direction, depending on the requirement.

## Assumptions
- Binary images are used, where object points are labeled as 1 and background points as 0.
- The image is padded with a border of 0’s to avoid objects merging with the image border.
- This algorithm is primarily for single regions, but it can be extended to multiple disjoint regions by processing each region individually.

## Algorithm for Tracing the Boundary
The following steps describe how to trace the boundary of a 1-valued region, `R`, in a binary image.

### Step 1: Initialize
- **Starting point**: Let the starting point, `b0`, be the uppermost-leftmost point in the image labeled as 1. 
- **Neighbor of starting point**: Denote the west neighbor of `b0` as `c0`, which is always a background point (0).
- **Examine 8-neighbors**: Start checking the 8-neighbors of `b0` from `c0` and proceed in a clockwise direction. Let `b1` be the first 1-valued neighbor encountered, and `c1` be the background point immediately preceding `b1`.

### Step 2: Set `b` and `c`
- Let $b = b0$ and $c = c0$.

### Step 3: Find Next Boundary Point
- **Examine neighbors**: For the current point `b`, examine its 8 neighbors, starting from `c` and moving clockwise. Denote these neighbors as `n1, n2, ..., n8`.
- **First 1-valued neighbor**: Find the first neighbor labeled as 1, and denote it by `nk`.
- Set $b = nk$ and $c = nk-1$.

### Step 4: Repeat Until Boundary is Traced
- Repeat Steps 3 and 4 until `b = b0`, the starting point, indicating the boundary is fully traced.
- The sequence of `b` points found during the process is the ordered set of boundary points.

### Algorithm Overview
- This algorithm follows the boundary in a clockwise direction, and the neighboring points are always examined in a clockwise order. 
- The algorithm guarantees that the correct boundary is traced, even for complex boundaries or boundaries with branches.

## Example with Complex Boundaries
- The algorithm works for boundaries with branches (Fig. 11.2a) or self-intersecting boundaries (Fig. 11.2b).
- Multiple boundaries (Fig. 11.2c) are handled by processing one boundary at a time.

## Extracting Inner Boundaries
- To find the boundaries of holes in a region (interior boundaries), one approach is to extract the holes as 1-valued regions on a 0-background.
- The boundary-following algorithm can then be applied to these regions to extract inner boundaries.

## Reversing Boundary Direction
- Although the algorithm traces boundaries in a clockwise direction, it can easily be reversed to trace boundaries in the counterclockwise direction by reversing the resulting sequence of points.

## Summary
- Boundary-following algorithms are essential for extracting the boundaries of regions in binary images.
- The Moore boundary tracing algorithm is a widely used technique that ensures correct boundary extraction, even for complex or self-intersecting boundaries.
- The algorithm can handle both outer and inner boundaries, making it versatile for various segmentation tasks.

# Chain Codes

Chain codes are used to represent a boundary by a connected sequence of straight-line segments of specified length and direction. We assume in this section that all curves are closed, simple curves (i.e., curves that are closed and not self-intersecting).

## Freeman Chain Codes

Typically, a chain code representation is based on 4- or 8-connectivity of the segments. The direction of each segment is coded by using a numbering scheme, as shown in Fig. 11.3. A boundary code formed as a sequence of such directional numbers is referred to as a Freeman chain code.

Digital images are usually acquired and processed in a grid format with equal spacing in the x- and y-directions, so a chain code could be generated by following a boundary in a clockwise direction and assigning a direction to the segments connecting every pair of pixels. However, this level of detail is typically avoided for two reasons:
1. The resulting chain would be quite long.
2. Small disturbances along the boundary due to noise or imperfect segmentation would cause changes in the code that may not reflect the principal shape features of the boundary.

### Resampling the Boundary
To address these issues, the boundary is resampled by selecting a larger grid spacing, as illustrated in Fig. 11.4(a). Then, as the boundary is traversed, a boundary point is assigned to a node of the coarser grid, depending on the proximity of the original boundary point to that node, as shown in Fig. 11.4(b). The resampled boundary can then be represented by a 4- or 8-code.

- The coarser boundary points are represented by an 8-directional chain code (Fig. 11.4(c)).
- It is simple to convert between 8-code and 4-code (refer to Problems 2.15, 9.27, and 9.29).

### Starting Point of the Boundary
The uppermost-leftmost point of the boundary is typically chosen as the starting point, as shown in Fig. 11.4(c). This choice minimizes the magnitude of the chain code.

### Chain Code Variations
Chain codes can be normalized with respect to the starting point, making the code independent of the starting location. Additionally, the chain code can be normalized for rotation (in angles that are integer multiples of the directions shown in Fig. 11.3) by using the first difference of the chain code instead of the code itself. This difference counts the number of direction changes in a counterclockwise direction.

### Example: Freeman Chain Code
- The Freeman chain code for the resampled boundary is:  
`0 0 0 0 6 0 6 6 6 6 6 6 6 6 4 4 4 4 4 4 2 4 2 2 2 2 2 0 2 22 0 2`

- The starting point of the boundary is at coordinates (2, 5) in the subsampled grid.

- The first difference of the chain code is:  
`0 0 0 6 2 6 0 0 0 0 0 0 0 6 0 0 0 0 0 6 2 6 0 0 0 0 6 2 0 66 2 6`

### Code Representation
The chain code offers a way to represent the boundary compactly, which reduces the amount of data required to store the boundary. Working with code numbers also provides a unified method for analyzing the shape of the boundary.

## Slope Chain Codes (SCCs)
An alternative to Freeman chain codes is the Slope Chain Code (SCC). The SCC of a 2-D curve is obtained by placing straight-line segments of equal length around the curve, with the endpoints of the segments touching the curve.

### Steps for Generating an SCC:
1. Select the length of the line segment.
2. Choose a starting point (the origin) and place a line segment at the origin and the other end at the curve. This point becomes the starting point for the next line segment.
3. Repeat the procedure until the starting point is reached (or the end point for open curves).

The SCC is based on the slope changes between contiguous line segments. Positive and zero slope changes are normalized to the open half interval $[0, 1]$, while negative slope changes are normalized to the open interval (-1, 0).

### Example of SCC Code:
For the curve in Fig. 11.6, the SCC code is:  
`0.0, 0.12, 0.20, 0.21, 0.11, -0.11, -0.12, -0.21, -0.22, -0.24, -0.28, -0.28, -0.31, -0.30`

### Mirror Image and Reversal
The inverse of an SCC is obtained by reversing the order of the symbols and their signs. The mirror image of a chain is obtained by reversing the signs of the symbols.

### Accuracy and Symbol Range
The accuracy of an SCC is determined by the range of slope changes. For example, a slope change accuracy of 10^-2 results in an "alphabet" of 199 possible symbols, and a resolution of 10^-1 produces an alphabet of 19 symbols.

### Closed Curves
The approach for SCCs is applicable to both open and closed curves. For closed curves, the curve-following process starts at an arbitrary point (e.g., the uppermost-leftmost point of the curve) and proceeds until the starting point is reached.

## Conclusion
Both Freeman chain codes and slope chain codes provide methods for representing the boundaries of curves. Freeman chain codes are simpler but may require resampling to smooth small variations, while slope chain codes offer a more continuous representation of curves with potentially more accuracy in capturing rotation.

# Boundary Approximations Using Minimum-Perimeter Polygons

A digital boundary can be approximated with arbitrary accuracy by a polygon. For a closed curve, the approximation becomes exact when the number of segments of the polygon is equal to the number of points in the boundary, so each pair of adjacent points defines a segment of the polygon. The goal of a polygonal approximation is to capture the essence of the shape in a given boundary using the fewest possible number of segments. 

Generally, this problem is not trivial, and can turn into a time-consuming iterative search. However, approximation techniques of modest complexity are well suited for image-processing tasks. One of the most powerful techniques is representing a boundary by a minimum-perimeter polygon (MPP).

## Foundation

An intuitive approach for computing MPPs is to enclose a boundary by a set of concatenated cells. Think of the boundary as a rubber band contained in these cells. As the rubber band is allowed to shrink, it will be constrained by the vertices of the inner and outer walls of the region of the gray cells. Ultimately, this shrinking produces the shape of a polygon of minimum perimeter. The size of the cells determines the accuracy of the polygonal approximation.

In the limit, if the size of each square cell corresponds to a pixel in the boundary, the maximum error in each cell between the boundary and the MPP approximation would be 2d, where d is the minimum possible distance between pixels. This error can be reduced in half by forcing each cell in the polygonal approximation to be centered on its corresponding pixel in the original boundary. The objective is to use the largest possible cell size acceptable in a given application.

The cellular approach reduces the shape of the object enclosed by the original boundary to the area circumscribed by the gray walls. If we traverse the boundary of the region, every turn encountered will be either a convex or a concave vertex. These are shown as white and blue dots, respectively, and can be the vertices of the MPP. Only convex vertices of the inner wall and concave vertices of the outer wall can be vertices of the MPP.

## MPP Algorithm

The set of cells enclosing a digital boundary is called a cellular complex. We assume the cellular complexes are simply connected, meaning the boundaries are not self-intersecting.

### Key Observations:

1. The MPP bounded by a simply connected cellular complex is not self-intersecting.
2. Every convex vertex of the MPP is a W vertex, but not every W vertex of a boundary is a vertex of the MPP.
3. Every mirrored concave vertex of the MPP is a B vertex, but not every B vertex of a boundary is a vertex of the MPP.
4. All B vertices are on or outside the MPP, and all W vertices are on or inside the MPP.
5. The uppermost-leftmost vertex in a sequence of vertices contained in a cellular complex is always a W vertex of the MPP.

The algorithm involves two "crawler" points: a white crawler (WC) and a blue crawler (BC). WC crawls along the convex (W) vertices, and BC crawls along the concave (B) vertices. 

The algorithm starts by setting both WC and BC at vertex 0. Then, the algorithm checks one of three conditions for each vertex in the sequence:

1. If the vertex is on the positive side of the line through the pair of points $V_WC, V_L$, the next MPP vertex is WC.
2. If the vertex is on the negative side of the line, or collinear, then the vertex becomes a candidate MPP vertex.
3. If the vertex is on the negative side of the line through pair $V_BC, V_L$, the next MPP vertex is BC.

The algorithm stops when it reaches the first vertex again, having processed all vertices in the polygon.

### Example 11.2: Numerical Example of MPP Algorithm

Consider the following vertices:

- V0 = (1, 4), V1 = (2, 3), V2 = (3, 3), V3 = (3, 2), V4 = (4, 1), V5 = (7, 1), V6 = (8, 2)

Using the algorithm, the MPP vertices are found by updating the white and blue crawlers as described. For example, starting with V0, the algorithm determines that V1 is a B vertex, so BC is updated. This process continues until all MPP vertices are found.

### Example 11.3: MPP Algorithm on a Maple Leaf Image

A 566x566 binary image of a maple leaf is used. The MPP representations of this boundary are shown using square cellular complex cells of various sizes (2, 4, 6, 8, 16, and 32). As the cell size increases, features like the stem are lost, while the main lobes of the leaf are preserved reasonably well even for a cell size of 16x16.

# SIGNATURES

A signature is a 1-D functional representation of a 2-D boundary and can be generated in various ways. One of the simplest methods is to plot the distance from the centroid to the boundary as a function of angle, as illustrated in Fig. 11.10. The basic idea of using signatures is to reduce the boundary representation to a 1-D function that is easier to describe than the original 2-D boundary.

## Key Concepts:

- **Scaling with respect to both axes**: The distance is calculated by sampling at equal intervals of angle (u).
- **Normalization**: When scaling shapes of different sizes, the amplitude values of the signature may change. A normalization method is used to scale all functions to the same range of values, e.g., [0, 1].
    - **Advantages**: Simplicity.
    - **Disadvantages**: The scaling depends only on two values: the minimum and maximum. If the shapes are noisy, this can introduce errors.

- **Variance-based normalization**: A more robust but computationally intensive approach is to scale using the variance of the signature. This method accounts for changes in size by scaling inversely with the variance.
    - **Outcome**: Variable scaling factor that compensates for changes in size, akin to automatic volume control.
    - **Objective**: Remove dependency on size while preserving the fundamental shape.

## Generating a Signature:

1. **Distance vs. angle (r(u) signature)**:
    - The distance from the centroid to the boundary is plotted as a function of angle.
  
2. **Tangent angle vs. boundary point**:
    - Another method to generate signatures is to traverse the boundary and plot the angle between the tangent line at each boundary point and a reference line. This gives information about basic shape characteristics.
    - **Result**: Horizontal segments indicate straight lines along the boundary, where the tangent angle remains constant.

3. **Slope density function**:
    - This function is a histogram of tangent-angle values.
    - **Purpose**: It responds to boundary segments with constant tangent angles (straight or nearly straight) and identifies sharp inflections (corners).
    - **Outcome**: A concentration of values is observed for straight segments, and deep valleys appear where rapid changes in the angle occur (sharp corners).

## EXAMPLE 11.4: Signatures of Two Regions

- **Figures**:
    - **Fig. 11.11(a) and (d)**: Show two binary objects.
    - **Fig. 11.11(b) and (e)**: Show their respective boundaries.
    - **Fig. 11.11(c) and (f)**: Display the corresponding r(u) signatures, ranging from 0° to 360° with 1° increments.
  
- **Observation**: The number of prominent peaks in the signatures is sufficient to differentiate the shapes of the two objects.

# SHAPE NUMBERS

The shape number of a Freeman chain-coded boundary, based on the 4-directional code of Fig. 11.3(a), is defined as the first difference of smallest magnitude. 

## Key Concepts:

- **Order (n)**: The order of a shape number is defined as the number of digits in its representation. The value of n is always even for a closed boundary, and it limits the number of possible different shapes.
- **First Difference**: The shape number is computed by finding the first difference of smallest magnitude in the Freeman chain code. This method is independent of rotation (in increments of 90°).
- **Grid Orientation**: The boundary's orientation can be normalized by aligning the chain-code grid with the sides of the basic rectangle.
- **Eccentricity and Grid Selection**:
    - For a given shape order (n), find the rectangle whose eccentricity best matches that of the basic rectangle.
    - Use the selected rectangle to establish the grid size for encoding the boundary.
    - Example: If n = 12, rectangles of order 12 (perimeter length = 12) could be 2x4, 3x3, or 1x5. Choose the rectangle with the best eccentricity match.
  
## Steps for Computing Shape Numbers:

1. **Identify the basic rectangle** for the given boundary.
2. **Find the closest rectangle** of order n. For example, if n = 18, a 3x6 rectangle is used.
3. **Align the chain-code grid** with the chosen rectangle and compute the Freeman chain code.
4. **Compute the shape number** by taking the first difference of the chain code.

## Example 11.7: Computing Shape Numbers

- **Given**: n = 18 for the boundary in Fig. 11.17(a).
- **Step 1**: Identify the basic rectangle (Fig. 11.17(b)).
- **Step 2**: Find the closest rectangle of order 18, which is a 3x6 rectangle (Fig. 11.17(c)).
- **Step 3**: Align the chain-code directions with the grid and compute the chain code.
- **Step 4**: Compute the shape number using the first difference of the chain code (Fig. 11.17(d)).

## Examples of Shape Numbers:

- **Order 4**:
    - Chain code: 0 3 2 1
    - Difference: 3 3 3 3
    - Shape no.: 3 3 3 3
- **Order 6**:
    - Chain code: 0 0 3 2 2 1
    - Difference: 3 0 3 3 0 3
    - Shape no.: 0 3 3 0 3 3
- **Order 8**:
    - Chain code: 0 0 3 3 2 2 1 1 0 3 0 3 2 2 1 1 0 0 0 3 2 2 2 1
    - Difference: 3 0 3 0 3 0 3 0 3 3 1 3 3 0 3 0 3 0 0 3 3 0 0 3
    - Shape no.: 0 3 0 3 3 1 3 3 0 0 3 3 0 0 3 30 3 0 3 0 3 0 3

**Figure 11.16**: All shapes of order 4, 6, and 8, with chain-code representations, first differences, and corresponding shape numbers.
